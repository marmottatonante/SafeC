#include "safec.h"
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <threads.h>

/*
    safeerr (Error Management)
*/

// Thread local variable to keep the last error generated by SafeC.
static thread_local safeerr safeerr_last = SAFEERR_SUCCESS;

// Writes new safeerr
static bool safeerr_write(safeerr result)
{
    safeerr_last = result;
    return result == SAFEERR_SUCCESS;
}

// Keeps last safeerr
static bool safeerr_keep()
{
    return safeerr_last == SAFEERR_SUCCESS;
}

// Reads last safeerr
safeerr safeerr_read(void)
{
    return safeerr_last;
}

/*
    safereg (Resource Registry)
*/

struct safereg_s
{
    safesyn sync;
    // safevec containing references, but there's no safevec yet
    size_t create_count; // Number of times safemem_create has been called
    size_t destroy_count; // Number of times safemem_destroy has been called
};

/*
    safesyn section
*/

bool safesyn_create(safesyn* new_safesyn, bool is_enabled)
{
    if(new_safesyn == NULL) return safeerr_write(SAFEERR_INVALID_ARGUMENT);

    memset(new_safesyn, 0, sizeof(safesyn));
    new_safesyn->is_enabled = is_enabled;
    
    if(!new_safesyn->is_enabled) return safeerr_write(SAFEERR_SUCCESS);
    new_safesyn->is_valid = mtx_init(&new_safesyn->lock, mtx_plain) == thrd_success;
    return safeerr_write(new_safesyn->is_valid ? SAFEERR_SUCCESS : SAFEERR_MUTEX_INIT_FAILED);
}

bool safesyn_lock(safesyn* sync)
{
    if(sync == NULL) return safeerr_write(SAFEERR_INVALID_ARGUMENT);
    if(!sync->is_enabled) return safeerr_write(SAFEERR_SUCCESS);
    if(!sync->is_valid) return safeerr_write(SAFEERR_MUTEX_IS_INVALID);

    if(mtx_lock(&sync->lock) != thrd_success)
        return safeerr_write(SAFEERR_MUTEX_LOCK_FAILED);
    else
        return safeerr_write(SAFEERR_SUCCESS);
}

bool safesyn_unlock(safesyn* sync)
{
    if(sync == NULL) return safeerr_write(SAFEERR_INVALID_ARGUMENT);
    if(!sync->is_enabled) return safeerr_write(SAFEERR_SUCCESS);
    if(!sync->is_valid) return safeerr_write(SAFEERR_MUTEX_IS_INVALID);

    if(mtx_unlock(&sync->lock) != thrd_success)
        return safeerr_write(SAFEERR_MUTEX_UNLOCK_FAILED);
    else
        return safeerr_write(SAFEERR_SUCCESS);
}

bool safesyn_destroy(safesyn* sync)
{
    if(sync == NULL) return safeerr_write(SAFEERR_INVALID_ARGUMENT);

    if(sync->is_enabled && sync->is_valid)
        mtx_destroy(&sync->lock);

    memset(sync, 0, sizeof(safesyn));
    return safeerr_write(SAFEERR_SUCCESS);
}

/*
    safemem section
*/

bool safemem_create(safemem* new_safemem, const size_t size, const bool is_managed, const bool is_concurrent)
{
    if(new_safemem == NULL || size == 0) return safeerr_write(SAFEERR_INVALID_ARGUMENT);
    
    memset(new_safemem, 0, sizeof(safemem));
    new_safemem->is_managed = is_managed;
    
    new_safemem->size = size;
    new_safemem->data = malloc(new_safemem->size);
    if(new_safemem->data == NULL) return safeerr_write(SAFEERR_MALLOC_FAILED);
    
    if(!safesyn_create(&new_safemem->sync, is_concurrent))
        return free(new_safemem->data), new_safemem->data = NULL, safeerr_keep();

    return safeerr_write(SAFEERR_SUCCESS);
}

bool safemem_destroy(safemem* mem)
{
    if(mem == NULL) return safeerr_write(SAFEERR_INVALID_ARGUMENT);

    if(safesyn_lock(&mem->sync))
        free(mem->data), safesyn_unlock(&mem->sync);

    safesyn_destroy(&mem->sync);
    memset(mem, 0, sizeof(safemem));

    return safeerr_write(SAFEERR_SUCCESS);
}